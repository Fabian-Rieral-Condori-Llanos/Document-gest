const VulnerabilityService = require('../services/vulnerability.service');
const Response = require('../utils/httpResponse');

/**
 * Vulnerability Controller
 * 
 * Maneja las peticiones HTTP relacionadas con la base de conocimiento de vulnerabilidades.
 */
class VulnerabilityController {
    /**
     * GET /api/vulnerabilities
     * Obtiene todas las vulnerabilidades
     */
    static async getAll(req, res) {
        try {
            const vulnerabilities = await VulnerabilityService.getAll();
            Response.Ok(res, vulnerabilities);
        } catch (err) {
            Response.Internal(res, err);
        }
    }

    /**
     * GET /api/vulnerabilities/export
     * Exporta vulnerabilidades (formato reducido)
     */
    static async export(req, res) {
        try {
            const vulnerabilities = await VulnerabilityService.export();
            Response.Ok(res, vulnerabilities);
        } catch (err) {
            Response.Internal(res, err);
        }
    }

    /**
     * GET /api/vulnerabilities/:id
     * Obtiene una vulnerabilidad por ID
     */
    static async getById(req, res) {
        try {
            const vulnerability = await VulnerabilityService.getById(req.params.id);
            Response.Ok(res, vulnerability);
        } catch (err) {
            Response.Internal(res, err);
        }
    }

    /**
     * POST /api/vulnerabilities
     * Crea nuevas vulnerabilidades
     */
    static async create(req, res) {
        try {
            let vulnerabilities = req.body;

            // Si no es array, convertir a array
            if (!Array.isArray(vulnerabilities)) {
                vulnerabilities = [vulnerabilities];
            }

            // Agregar creator a cada vulnerabilidad
            vulnerabilities = vulnerabilities.map(v => ({
                ...v,
                creator: req.decodedToken.id
            }));

            const result = await VulnerabilityService.create(vulnerabilities);
            Response.Created(res, result);
        } catch (err) {
            Response.Internal(res, err);
        }
    }

    /**
     * PUT /api/vulnerabilities/:id
     * Actualiza una vulnerabilidad
     */
    static async update(req, res) {
        try {
            const updateData = req.body;
            const vulnerability = await VulnerabilityService.update(req.params.id, updateData);
            Response.Ok(res, vulnerability);
        } catch (err) {
            Response.Internal(res, err);
        }
    }

    /**
     * DELETE /api/vulnerabilities/:id
     * Elimina una vulnerabilidad
     */
    static async delete(req, res) {
        try {
            await VulnerabilityService.delete(req.params.id);
            Response.Ok(res, 'Vulnerability deleted successfully');
        } catch (err) {
            Response.Internal(res, err);
        }
    }

    /**
     * POST /api/vulnerabilities/delete
     * Elimina múltiples vulnerabilidades
     */
    static async deleteMany(req, res) {
        try {
            const { vulnerabilityIds } = req.body;

            if (!vulnerabilityIds || !Array.isArray(vulnerabilityIds)) {
                return Response.BadParameters(res, 'vulnerabilityIds array is required');
            }

            const result = await VulnerabilityService.deleteMany(vulnerabilityIds);
            Response.Ok(res, result);
        } catch (err) {
            Response.Internal(res, err);
        }
    }

    /**
     * POST /api/vulnerabilities/merge
     * Combina dos vulnerabilidades
     */
    static async merge(req, res) {
        try {
            const { vulnIdFrom, vulnIdTo } = req.body;

            if (!vulnIdFrom || !vulnIdTo) {
                return Response.BadParameters(res, 'vulnIdFrom and vulnIdTo are required');
            }

            const result = await VulnerabilityService.merge(vulnIdFrom, vulnIdTo);
            Response.Ok(res, result);
        } catch (err) {
            Response.Internal(res, err);
        }
    }

    /**
     * GET /api/vulnerabilities/find
     * Busca vulnerabilidad por título
     */
    static async findByTitle(req, res) {
        try {
            const { title, locale } = req.query;

            if (!title) {
                return Response.BadParameters(res, 'title query parameter is required');
            }

            const vulnerability = await VulnerabilityService.findByTitle(title, locale);
            Response.Ok(res, vulnerability);
        } catch (err) {
            Response.Internal(res, err);
        }
    }
}

module.exports = VulnerabilityController;