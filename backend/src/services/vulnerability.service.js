const mongoose = require('mongoose');
const Vulnerability = mongoose.model('Vulnerability');

class VulnerabilityService {
    /**
     * Obtiene todas las vulnerabilidades
     */
    static async getAll() {
        return Vulnerability.find()
            .populate('creator', '-_id username')
            .exec();
    }

    /**
     * Obtiene vulnerabilidades para exportación
     */
    static async export() {
        return Vulnerability.find()
            .select(Vulnerability.exportFields)
            .exec();
    }

    /**
     * Obtiene una vulnerabilidad por ID
     * @param {string} vulnId
     */
    static async getById(vulnId) {
        const vuln = await Vulnerability.findById(vulnId)
            .populate('creator', '-_id username')
            .exec();

        if (!vuln) {
            throw { fn: 'NotFound', message: 'Vulnerability not found' };
        }

        return vuln;
    }

    /**
     * Busca vulnerabilidad por título en un locale específico
     * @param {string} title
     * @param {string} locale
     */
    static async findByTitle(title, locale) {
        return Vulnerability.findOne({
            'details.title': title,
            'details.locale': locale
        }).exec();
    }

    /**
     * Crea nuevas vulnerabilidades
     * @param {Array} vulnerabilities
     */
    static async create(vulnerabilities) {
        try {
            const result = await Vulnerability.insertMany(vulnerabilities, { ordered: false });
            return { created: result.length, duplicates: 0 };
        } catch (err) {
            if (err.code === 11000) {
                if (err.result && err.result.insertedCount === 0) {
                    throw { fn: 'BadParameters', message: 'Vulnerability title already exists' };
                }
                return {
                    created: err.result ? err.result.insertedCount : 0,
                    duplicates: err.writeErrors ? err.writeErrors.length : 0
                };
            }
            throw err;
        }
    }

    /**
     * Actualiza una vulnerabilidad
     * @param {string} vulnId
     * @param {Object} vulnData
     */
    static async update(vulnId, vulnData) {
        try {
            const vuln = await Vulnerability.findByIdAndUpdate(
                vulnId,
                vulnData,
                { new: true }
            );

            if (!vuln) {
                throw { fn: 'NotFound', message: 'Vulnerability not found' };
            }

            return vuln;
        } catch (err) {
            if (err.code === 11000) {
                throw { fn: 'BadParameters', message: 'Vulnerability title already exists' };
            }
            throw err;
        }
    }

    /**
     * Elimina una vulnerabilidad
     * @param {string} vulnId
     */
    static async delete(vulnId) {
        const vuln = await Vulnerability.findByIdAndDelete(vulnId);

        if (!vuln) {
            throw { fn: 'NotFound', message: 'Vulnerability not found' };
        }

        return vuln;
    }

    /**
     * Elimina múltiples vulnerabilidades
     * @param {Array} vulnIds
     */
    static async deleteMany(vulnIds) {
        const result = await Vulnerability.deleteMany({ _id: { $in: vulnIds } });
        return { deletedCount: result.deletedCount };
    }

    /**
     * Combina vulnerabilidades (merge)
     * @param {string} vulnIdFrom - ID de la vulnerabilidad origen
     * @param {string} vulnIdTo - ID de la vulnerabilidad destino
     */
    static async merge(vulnIdFrom, vulnIdTo) {
        const vulnFrom = await Vulnerability.findById(vulnIdFrom);
        const vulnTo = await Vulnerability.findById(vulnIdTo);

        if (!vulnFrom || !vulnTo) {
            throw { fn: 'NotFound', message: 'Vulnerability not found' };
        }

        // Combinar detalles
        for (const detail of vulnFrom.details) {
            const existingLocale = vulnTo.details.find(d => d.locale === detail.locale);
            if (!existingLocale) {
                vulnTo.details.push(detail);
            }
        }

        await vulnTo.save();
        await Vulnerability.findByIdAndDelete(vulnIdFrom);

        return vulnTo;
    }

    /**
     * Exporta vulnerabilidades para backup
     * @param {string} path
     */
    static async backup(path) {
        const fs = require('fs');

        return new Promise((resolve, reject) => {
            const writeStream = fs.createWriteStream(`${path}/vulnerabilities.json`);
            writeStream.write('[');

            let vulns = Vulnerability.find().cursor();
            let isFirst = true;

            vulns.eachAsync(async (document) => {
                if (!isFirst) {
                    writeStream.write(',');
                } else {
                    isFirst = false;
                }
                writeStream.write(JSON.stringify(document, null, 2));
            })
            .then(() => {
                writeStream.write(']');
                writeStream.end();
            })
            .catch(reject);

            writeStream.on('finish', () => resolve());
            writeStream.on('error', reject);
        });
    }

    /**
     * Restaura vulnerabilidades desde backup
     * @param {string} path
     * @param {string} mode
     */
    static async restore(path, mode = 'upsert') {
        const fs = require('fs');
        const JSONStream = require('JSONStream');

        if (mode === 'revert') {
            await Vulnerability.deleteMany();
        }

        return new Promise((resolve, reject) => {
            let documents = [];

            const readStream = fs.createReadStream(`${path}/vulnerabilities.json`);
            const jsonStream = JSONStream.parse('*');
            readStream.pipe(jsonStream);

            readStream.on('error', reject);

            jsonStream.on('data', async (document) => {
                documents.push(document);
                if (documents.length === 100) {
                    await Vulnerability.bulkWrite(documents.map(doc => ({
                        replaceOne: {
                            filter: { _id: doc._id },
                            replacement: doc,
                            upsert: true
                        }
                    })));
                    documents = [];
                }
            });

            jsonStream.on('end', async () => {
                if (documents.length > 0) {
                    await Vulnerability.bulkWrite(documents.map(doc => ({
                        replaceOne: {
                            filter: { _id: doc._id },
                            replacement: doc,
                            upsert: true
                        }
                    })));
                }
                resolve();
            });

            jsonStream.on('error', reject);
        });
    }
}

module.exports = VulnerabilityService;